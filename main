from NN import NeuralNetwork 
from NN2 import NeuralNetwork2
import time
import random
from matrices import mm
from layers import *
import numpy as np

def timer():
    start_time = time.perf_counter()
    end_time = time.perf_counter()
    elapsed_time = end_time - start_time
    print("Elapsed time: ", elapsed_time)
#timer()

def main():
    
    data = [[0, 0], [0, 1], [1, 0], [1, 1]]
    results = [[0], [1], [1], [0]]
    obj0 = Hidden(2)
    obj1 = ReLU()    
    obj2 = Hidden(10)
    obj3 = ReLU()
    obj4 = Hidden(10)
    obj5 = ReLU()
    obj6 = Hidden(10)
    o7 = ReLU()
    o8 = Hidden(10)
    o9 = ReLU()
    o10 = Hidden(1)
    nt = NeuralNetwork("MY_NN")
    nt.addLayer(obj0)
    nt.addLayer(obj1)
    nt.addLayer(obj2)
    nt.addLayer(obj3)
    nt.addLayer(obj4)
    nt.addLayer(obj5)
    '''
    nt.addLayer(obj6)
    nt.addLayer(o7)    
    nt.addLayer(o8)
    nt.addLayer(o9)
    '''
    nt.addLayer(o10)
    nt.training(data, results, 0.001 , 10000)
    
    print(nt.propagate_forwards([[0], [0]]))
    print(nt.propagate_forwards([[1], [0]]))
    print(nt.propagate_forwards([[0], [1]]))
    print(nt.propagate_forwards([[1], [1]]))
    


def m(a):
    for i in a:
        print(i)
    print("\n")


def main2():
    data = [[0, 0], [0, 1], [1, 0], [1, 1]]
    results = [[0], [1], [1], [0]]

    n = NeuralNetwork2("nut")
    layers = [["Hidden", 2], ["ReLU"], ["Hidden", 10], ["ReLU"], ["Hidden", 10], ["ReLU"], ["Hidden", 1]]
    for layer in layers:
        n.addLayer(layer)
    
    #n.displayLayers()

    n.training(data, results, 0.001, 10000)

    print(n.propagate_forwards([[0], [0]]))
    print(n.propagate_forwards([[1], [0]]))
    print(n.propagate_forwards([[0], [1]]))
    print(n.propagate_forwards([[1], [1]]))


def proc():
    file = open("mnist_train.csv", "r")
    file2 = open("processedData.txt", "w")
    for i in file:
        y = [0]*10
        y[int(i[0])] = 1
        x = list(map(lambda n: int(n)/255, i[:-1].split(",")[1:]))
        item = [x, y]
        file2.write(f"{str(item)}\n")
    file.close()
    file2.close()

    
def retProc():
    file2 = open("processedData.txt", "r")
    data = []
    for i in file2:
        data.append(eval(i))
    return data

def getMax(lis):
    mx = 0
    c = 0
    tmp = 0
    for i in lis:
        if i > mx:
            mx = i
            tmp = c
        c+=1
    return tmp
    

def MNIST_TRAIN():
    mnist = retProc()
    train = mnist[:1000]

    mNetwork = NeuralNetwork2("MNIST2")
    #layers = [["Hidden", 784], ["ReLU"], ["Hidden", 100], ["ReLU"], ["Hidden", 100], ["ReLU"], ["Hidden", 100], ["ReLU"], ["Softmax"], ["Hidden", 10]]
    layers = [["Hidden", 784], ["ReLU"], ["Hidden", 10], ["ReLU"], ["Softmax"], ["Hidden", 10]]

    for layer in layers:
        mNetwork.addLayer(layer)

    data = []
    results = []
    for i in train:
        data.append(i[0])
        results.append(i[1])
    

    mNetwork.training(data, results, 0.01, 100)
    mNetwork.saveNN()


def MNIST_TEST():
    mnist = retProc()    
    n = NeuralNetwork2.upload_saved("MNIST2")

    correct = 0
    total = 0
    for i in range(50000):    
        outp = n.propagate_forwards(mm.alter_dim(mnist[1001+i][0], [0, 1]))
        res = mnist[1001+i][1]
        tmp = []
        for i in outp:
            tmp.append(i[0])
        pred = getMax(tmp)
        tru = getMax(res)
        total += 1
        if pred == tru:
            correct +=1
        if total%500==0:
            print(f"progress: {(total*100)/50000}% complete")    
    
    accuracy = (correct*100)/total
    print(f"\nAccuracy of the neural network: {accuracy}%\n")


def dispM(matrix):
    for i in matrix:
        print(i)

'''
Inp = [mm.makematrix(3, 3, 10),mm.makematrix(3, 3, 5)]
Ip = [mm.makematrix(3, 3, 4),mm.makematrix(3, 3, 4)]
n = NeuralNetwork2("nut")
n.addLayer(["Convolutional", 2, 3, (3,3), (2,2)])
outp= n.propagate_forwards(Inp)
outp = mm.scalematrix(outp, 0.01)
n.propagate_backwards(outp, 0.1)

'''
# implement max-pooling layer 

Inp = [mm.makematrix(6, 6, [1, 5]),mm.makematrix(6, 6, [10,15])]
for i in Inp:
    dispM(i)
    print('\n')
n = NeuralNetwork2("nut")
n.addLayer(["MaxPooling",(2,2), 2])
y = n.propagate_forwards(Inp)
for i in y:
    dispM(i)
    print('\n')
z = [mm.makematrix(3,3, 1),mm.makematrix(3,3, 1)]

out = n.propagate_backwards(y,8)
for i in out:
    dispM(i)
    print('\n')
