from matrices import mm
from layers import *
import time

class NeuralNetwork2:
    savedNetworks = []
    file = open("savedNetwork.txt", "r")
    for i in file:
        savedNetworks.append(i[:-1])
    file.close()
    
    @classmethod
    def view_saved(cls):
        for item in cls.savedNetworks[::2]:
            print(item, end  = ". ")
            
    @staticmethod
    def upload_saved(name):
        if name not in NeuralNetwork2.savedNetworks:
            return f"Error: '{name}' does not exist."
        else:
            index = NeuralNetwork2.savedNetworks.index(name)
            cont = eval(NeuralNetwork2.savedNetworks[index+1])
            uploadedNN = NeuralNetwork2(name)
            for layer in cont:
                uploadedNN.addLayer(layer)
            return uploadedNN
            
    def __init__(self, name):
        self.layers = []
        self.name = name
        #Index of latest hidden layer in nn, so as to be initialised with values if new hidden layer added
        self.lastHidden = None
             
    def addLayer(self, layer):
        
        #layer[0] contains the layer type
        if layer[0] == "Hidden":
            layerObject = Hidden(layer[1])
            #if the layer type is Hidden, will contain second item in list for number of neurons in this layer
            #if layer list length is greater than two, means there are values to assign parameters, so do not initialise.
            if len(layer) > 2:
                layerObject.setWeights(layer[2])
                layerObject.setNLbiases(layer[3])
            #otherwise, initialise params of previous Hidden layer
            elif self.lastHidden is not None:
                n = self.lastHidden
                xavier = 1/(self.layers[n].getNeurons())
                self.layers[n].setWeights(mm.makematrix(layer[1], self.layers[n].getNeurons(), [-xavier, xavier]))
                #XAVIER INITIALISATION
                self.layers[n].setNLbiases(mm.makematrix(layer[1], 1, 0.01))
            self.lastHidden = len(self.layers)
            
        elif layer[0] == "Convolutional":
            layerObject = Convolutional(layer[1], layer[2], layer[3], layer[4])
            if len(layer) > 5:
                layerObject.setKernels(layer[5])
                layerObject.setBiases(layer[6])
            else:
                kernels = []
                biases = []
                bias_size = ((layer[3][0]-layer[4][0]+1),(layer[3][1]-layer[4][1]+1))
                for i in range(layer[2]):
                    biases.append(mm.makematrix(bias_size[0], bias_size[1], [-1,1]))
                    temp = []
                    for j in range(layer[1]):
                        temp.append(mm.makematrix(layer[4][0], layer[4][1], [-0.5, 0.5]))
                    kernels.append(temp)
                layerObject.setKernels(kernels)
                layerObject.setBiases(biases)
                    
        elif layer[0] == "ReLU":
            layerObject = ReLU()
            
        elif layer[0] == "Softmax":
            layerObject = Softmax()
            
        elif layer[0] == "MaxPooling":
            layerObject = MaxPooling(layer[1], layer[2])
            
        else:
            return "Invalid layer type"
        
        layerObject.setIndex(len(self.layers))
        self.layers.append(layerObject)

    def propagate_forwards(self, inp):
        for layer in self.layers:
            inp = layer.forward(inp)       
        return inp
    
    def propagate_backwards(self, dE_dO, rate):
        for layer in self.layers[::-1]:
            dE_dO = layer.backward(dE_dO, rate)
        return dE_dO
    
    def learn(self, inp, val_true, rate):
        inp = mm.copy(inp)
        output = self.propagate_forwards(inp)
        error = mm.msError(output, val_true)
        dE_dO = mm.dE_dO(output, val_true)
        self.propagate_backwards(dE_dO, rate)
       
    def training(self, data, results, rate, cycles):
        start = 0
        end=0
        for cycle in range(cycles):
            if cycle == 0:
                start = time.time()
            if cycle == 9:
                end = time.time()
            nums = mm.testrand(len(data))
            for i in nums:  
                self.learn(mm.alter_dim(data[i], [0, 1]), mm.alter_dim(results[i], [0, 1]), rate)
            print(cycle+1)
            if (cycle+1)%10 == 0:
                print(f"Est time until completion: {(end-start)*(10-((cycle+1)/10))}")
                
    def saveNN(self):
        if self.name in NeuralNetwork2.savedNetworks:
            print("Network of this name already exists.")
        else:
            allLayers = []
            for layer in self.layers:
                layerInfo = []
                layerInfo.append(layer.getType())
                if layer.getType() == "Hidden":
                    layerInfo.append(layer.getNeurons())
                    layerInfo.append(layer.getWeights())
                    layerInfo.append(layer.getNLbiases())
                elif layer.getType() == "Convolutional":
                    layerInfo.append(layer.getInput_depth())
                    layerInfo.append(layer.getOutput_depth())
                    layerInfo.append(layer.getInput_size())
                    layerInfo.append(layer.getKernel_size())
                    layerInfo.append(layer.getKernals())
                    layerInfo.append(layer.getBiases())
                elif layer.getType() == "MaxPooling":
                    layerInfo.append(layer.getSize())
                    layerInfo.append(layer.getStride())
                allLayers.append(layerInfo)
            file = open("savedNetwork.txt", "a")
            file.write(f"{self.name}\n{allLayers}\n")
            file.close()
            NeuralNetwork2.savedNetworks.append(self.name)
            NeuralNetwork2.savedNetworks.append(str(allLayers))
            
    def displayLayers(self):
        for layer in self.layers:
            print(layer.getType())
            '''
            if layer.getType() == "Hidden":
                print(layer.getNeurons())
                
                print(layer.getWeights())
                print(layer.getNLbiases())
                
            if layer.getType() == "Convolutional":
                print(layer.getKernels())
                print(len(layer.getKernels()))
                print(layer.getBiases())'''
                
            if layer.getType() == "MaxPooling":
                print(layer.getSize())
                print(layer.getStride())
        
